[
    {
        "id": "2bc2d46292aae71f",
        "type": "inject",
        "z": "73619a0e20b766b0",
        "name": "Update Weather (every 5min)",
        "props": [
            {
                "p": "payload"
            }
        ],
        "repeat": "300",
        "crontab": "",
        "once": true,
        "onceDelay": "5",
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 490,
        "y": 480,
        "wires": [
            [
                "b3cfd559401f9bfa"
            ]
        ]
    },
    {
        "id": "b3cfd559401f9bfa",
        "type": "http request",
        "z": "73619a0e20b766b0",
        "name": "Get Real-time Weather",
        "method": "GET",
        "ret": "obj",
        "paytoqs": "ignore",
        "url": "https://api.openweathermap.org/data/2.5/weather?q=Luxembourg&units=metric&appid=API-ID",
        "tls": "",
        "persist": false,
        "proxy": "",
        "insecureHTTPParser": false,
        "authType": "",
        "senderr": false,
        "headers": [],
        "x": 760,
        "y": 480,
        "wires": [
            [
                "733d598a4f7b149d",
                "c27f425065c71028"
            ]
        ]
    },
    {
        "id": "c27f425065c71028",
        "type": "debug",
        "z": "73619a0e20b766b0",
        "name": "Weather API Response",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 770,
        "y": 420,
        "wires": []
    },
    {
        "id": "733d598a4f7b149d",
        "type": "function",
        "z": "73619a0e20b766b0",
        "name": "Extract Weather Data",
        "func": "// Check if we have valid data\nif (!msg.payload || !msg.payload.main || !msg.payload.weather) {\n    node.error(\"Invalid weather data received\");\n    return null;\n}\n\n// Extract and format data\nconst weather = msg.payload;\n\n// Current time\nconst now = new Date();\nconst hours = now.getHours();\nconst minutes = now.getMinutes();\nconst timeStr = hours + ':' + (minutes < 10 ? '0' : '') + minutes;\n\n// Round temperature to nearest integer\nconst temperature = Math.round(weather.main.temp);\n\n// Store all data in flow context\nflow.set('temperature', temperature + '°C');\nflow.set('humidity', weather.main.humidity + '%');\nflow.set('wind', Math.round(weather.wind.speed) + ' km/h');\n\n// Ensure we have weather description\nlet description = \"Unknown\";\nif (weather.weather && weather.weather.length > 0 && weather.weather[0].description) {\n    description = weather.weather[0].description;\n}\nflow.set('description', description);\n\n// Store city name and current time\nflow.set('city', weather.name + ' ' + timeStr);\n\n// Store current time separately for time display\nflow.set('current_time', timeStr);\n\n// Set default display mode if not set\nif (!flow.get('display_mode')) {\n    flow.set('display_mode', 'temperature');\n}\n\n// Get switches mode - check if switches have changed\nconst switchesMode = flow.get('switches_mode') || 'time';\n\n// Send current switches mode to the display handler\nmsg.payload = switchesMode;\n\n// Add last_updated timestamp to track successful updates\nflow.set('last_updated', Date.now());\n\nreturn msg;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 990,
        "y": 480,
        "wires": [
            [
                "b43b064180d72d86",
                "1996b9100a3bb7f4"
            ]
        ]
    },
    {
        "id": "b43b064180d72d86",
        "type": "debug",
        "z": "73619a0e20b766b0",
        "name": "Weather Data Processed",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 1050,
        "y": 420,
        "wires": []
    },
    {
        "id": "33bac39479946e4c",
        "type": "inject",
        "z": "73619a0e20b766b0",
        "name": "Error Recovery (every hour)",
        "props": [
            {
                "p": "payload"
            }
        ],
        "repeat": "3600",
        "crontab": "",
        "once": false,
        "onceDelay": 0,
        "topic": "",
        "payload": "check",
        "payloadType": "str",
        "x": 520,
        "y": 540,
        "wires": [
            [
                "1d5642a82f5f8ae0"
            ]
        ]
    },
    {
        "id": "1d5642a82f5f8ae0",
        "type": "function",
        "z": "73619a0e20b766b0",
        "name": "Check Last Update Time",
        "func": "// Get last update timestamp\nconst lastUpdated = flow.get('last_updated') || 0;\nconst now = Date.now();\n\n// If no update in the last 20 minutes (1200000ms), force refresh\nif (now - lastUpdated > 1200000) {\n    node.warn(\"No weather updates for 20+ minutes. Forcing refresh.\");\n    // Set payload to trigger a new weather fetch\n    msg.payload = Date.now();\n    return msg;\n}\n\n// Otherwise no need to do anything\nreturn null;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 760,
        "y": 540,
        "wires": [
            [
                "b3cfd559401f9bfa"
            ]
        ]
    },
    {
        "id": "7cc62c26b68a04ba",
        "type": "comment",
        "z": "73619a0e20b766b0",
        "name": "WEATHER DATA SECTION",
        "info": "",
        "x": 510,
        "y": 380,
        "wires": []
    },
    {
        "id": "3e8f8cd8f307e956",
        "type": "inject",
        "z": "73619a0e20b766b0",
        "name": "Initialize & Clear LCD",
        "props": [
            {
                "p": "topic",
                "vt": "str"
            },
            {
                "p": "payload"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": true,
        "onceDelay": "1",
        "topic": "init",
        "payload": "",
        "payloadType": "str",
        "x": 1920,
        "y": 1020,
        "wires": [
            [
                "ab0cf9e476c8846c"
            ]
        ]
    },
    {
        "id": "d72a326f373d8fc1",
        "type": "exec",
        "z": "73619a0e20b766b0",
        "command": "python /home/star2050/digilab/lcd/init.py",
        "addpay": "",
        "append": "--line 1 --message \"Initializing...\" && python /home/star2050/digilab/lcd/init.py --line 2 --message \"Please wait\"",
        "useSpawn": "false",
        "timer": "",
        "winHide": false,
        "oldrc": false,
        "name": "Run Init/Clear Script",
        "x": 2320,
        "y": 1020,
        "wires": [
            [
                "21f554a9c2ef9cce"
            ],
            [
                "4c9ad6a9d113f758"
            ],
            [
                "5af4fd7514fecd4c"
            ]
        ]
    },
    {
        "id": "21f554a9c2ef9cce",
        "type": "debug",
        "z": "73619a0e20b766b0",
        "name": "Init stdout",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "x": 2560,
        "y": 980,
        "wires": []
    },
    {
        "id": "4c9ad6a9d113f758",
        "type": "debug",
        "z": "73619a0e20b766b0",
        "name": "Init stderr",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "x": 2560,
        "y": 1020,
        "wires": []
    },
    {
        "id": "5af4fd7514fecd4c",
        "type": "debug",
        "z": "73619a0e20b766b0",
        "name": "Init RC",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "x": 2550,
        "y": 1060,
        "wires": []
    },
    {
        "id": "354130156739c815",
        "type": "comment",
        "z": "73619a0e20b766b0",
        "name": "LCD DISPLAY SECTION",
        "info": "",
        "x": 430,
        "y": 780,
        "wires": []
    },
    {
        "id": "1996b9100a3bb7f4",
        "type": "function",
        "z": "73619a0e20b766b0",
        "name": "Update Display Based on Mode",
        "func": "// Get current switches mode\nconst switchesMode = flow.get('switches_mode') || 'time';\n\n// DEBUG mode\nnode.log(\"DISPLAY HANDLER - Current mode: \" + switchesMode);\n\n// Get weather display mode (only applies when in weather mode)\nconst weatherMode = flow.get('weather_mode') || 'temperature';\n\n// Get data from flow context\nconst temperature = flow.get('temperature') || 'N/A';\nconst humidity = flow.get('humidity') || 'N/A';\nconst wind = flow.get('wind') || 'N/A';\nconst description = flow.get('description') || 'N/A';\nconst city = flow.get('city') || 'Connecting...';\n\n// Time-specific data\nconst now = new Date();\nconst hours = now.getHours();\nconst minutes = now.getMinutes();\nconst seconds = now.getSeconds();\nconst timeStr = hours + ':' + (minutes < 10 ? '0' : '') + minutes + ':' + (seconds < 10 ? '0' : '') + seconds;\nconst dateStr = now.toLocaleDateString('de-DE');\n\n// Clean function to remove/replace problematic characters\nfunction cleanText(text) {\n    if (typeof text !== 'string') return 'N/A';\n\n    // Replace HTML entities and problematic characters\n    return text\n        .replace(/&#x2F;/g, '|')         // Replace HTML entity for slash\n        .replace(/&#(\\d+);/g, '')        // Remove all other HTML entities\n        .replace(/[^\\x20-\\x7E]/g, '')    // Keep only basic ASCII characters\n        .replace(/[^\\w\\s.,°%\\/-:$^v]/g, ''); // Keep alphanumeric, spaces, and crypto symbols ($ ^ v)\n}\n\n// Ensure values are strings and limit to display width (16 chars for standard LCD)\nfunction formatForDisplay(text, maxLength = 16) {\n    let cleaned = cleanText(String(text));\n    return cleaned.length > maxLength ? cleaned.substring(0, maxLength) : cleaned;\n}\n\n// Clean all displayed text\nconst cleanCity = formatForDisplay(city);\nconst cleanTemp = formatForDisplay(temperature);\nconst cleanHumidity = formatForDisplay(humidity);\nconst cleanWind = formatForDisplay(wind);\nconst cleanTimeStr = formatForDisplay(timeStr);\nconst cleanDateStr = formatForDisplay(dateStr);\n\n// Special formatting for description - capitalize first letter\nlet cleanDescription = formatForDisplay(description);\nif (cleanDescription.length > 0) {\n    cleanDescription = cleanDescription.charAt(0).toUpperCase() + cleanDescription.slice(1);\n}\n\n// Prepare messages for line 1 and 2\nlet line1;\nlet line2;\n\n// Mode 1: Time display (both switches OFF)\nif (switchesMode === 'time') {\n    line1 = { payload: \"Datum : \" + cleanDateStr, line: 1 };\n    line2 = { payload: cleanTimeStr, line: 2 };\n    node.log(\"Display set to TIME mode\");\n}\n// Mode 2: Weather display (switch 1 ON, switch 2 OFF)\nelse if (switchesMode === 'weather') {\n    // Sub-modes for weather display based on weatherMode\n    node.log(\"Display set to WEATHER mode, sub-mode: \" + weatherMode);\n    switch (weatherMode) {\n        case 'temperature':\n            line1 = { payload: \"Temperatur\", line: 1 };\n            line2 = { payload: cleanTemp, line: 2 };\n            break;\n        case 'humidity':\n            line1 = { payload: \"Luftfeuchtigkeit\", line: 1 };\n            line2 = { payload: cleanHumidity, line: 2 };\n            break;\n        case 'wind':\n            line1 = { payload: \"Windgeschwindigk.\", line: 1 };\n            line2 = { payload: cleanWind, line: 2 };\n            break;\n        case 'description':\n            line1 = { payload: \"Wetterlage\", line: 1 };\n            line2 = { payload: cleanDescription, line: 2 };\n            break;\n        default:\n            line1 = { payload: \"Temperatur\", line: 1 };\n            line2 = { payload: cleanTemp, line: 2 };\n    }\n}\n// Mode 3: Stock info (switch 1 OFF, switch 2 ON)\nelse if (switchesMode === 'Stock') {\n    node.log(\"Display set to STOCK mode\");\n\n    // Hole alle gespeicherten Werte aus dem Flow-Kontext\n    const stockPrice = flow.get('stock_price') || 'N/A';\n    const stockChange = flow.get('stock_change') || 'N/A';\n    const stockSymbol = flow.get('stock_symbol') || 'AAPL';\n    const currentTime = flow.get('current_time') || 'N/A';\n\n    // Hole Stock-Display-Modus\n    const stockMode = flow.get('stock_mode') || 'price';\n\n    // Log für Debug\n    node.log(\"Stock Mode: \" + stockMode + \", Symbol: \" + stockSymbol + \", Price: \" + stockPrice);\n\n    switch (stockMode) {\n        case 'price':\n            // Zeige Symbol und aktuellen Preis\n            line1 = { payload: formatForDisplay(stockSymbol + \" Kurs\"), line: 1 };\n            line2 = { payload: formatForDisplay(stockPrice), line: 2 };\n            node.log(\"Displaying PRICE mode: \" + stockSymbol + \" - \" + stockPrice);\n            break;\n\n        case 'change':\n            // Zeige Symbol und Kursänderung\n            line1 = { payload: formatForDisplay(stockSymbol + \" Change\"), line: 1 };\n            line2 = { payload: formatForDisplay(stockChange), line: 2 };\n            node.log(\"Displaying CHANGE mode: \" + stockSymbol + \" - \" + stockChange);\n            break;\n\n        case 'full':\n            // Zeige Symbol + Preis in Zeile 1, Änderung in Zeile 2\n            const fullLine1 = stockSymbol + \" \" + stockPrice;\n            line1 = { payload: formatForDisplay(fullLine1), line: 1 };\n            line2 = { payload: formatForDisplay(stockChange), line: 2 };\n            node.log(\"Displaying FULL mode: \" + fullLine1 + \" | \" + stockChange);\n            break;\n\n        default:\n            // Fallback: Zeige nur Symbol und Preis\n            node.warn(\"Unknown stock mode: \" + stockMode + \", defaulting to price display\");\n            line1 = { payload: formatForDisplay(stockSymbol + \" Kurs\"), line: 1 };\n            line2 = { payload: formatForDisplay(stockPrice), line: 2 };\n            break;\n    }\n\n    // Zusätzliche Debug-Informationen\n    node.log(\"Final display - Line 1: '\" + line1.payload + \"', Line 2: '\" + line2.payload + \"'\");\n}\n// Mode 4: Kryptowährungs-Modus (both switches ON)\nelse if (switchesMode === 'crypto') {\n    node.log(\"Display set to CRYPTO mode\");\n\n    // Hole alle gespeicherten Werte aus dem Flow-Kontext\n    const cryptoPrice = flow.get('crypto_price') || 'N/A';\n    const cryptoChange = flow.get('crypto_change') || 'N/A';\n    const cryptoSymbol = flow.get('crypto_symbol') || 'BTC';\n    const cryptoName = flow.get('crypto_name') || 'Bitcoin';\n    const currentTime = flow.get('current_time') || 'N/A';\n\n    // Hole Crypto-Display-Modus\n    const cryptoMode = flow.get('crypto_mode') || 'price';\n    \n    // Log für Debug\n    node.log(\"Crypto Mode: \" + cryptoMode + \", Symbol: \" + cryptoSymbol + \", Price: \" + cryptoPrice);\n\n    switch (cryptoMode) {\n        case 'price':\n            // Zeige Symbol und aktuellen Preis\n            line1 = { payload: formatForDisplay(cryptoSymbol + \" Kurs\"), line: 1 };\n            line2 = { payload: formatForDisplay(cryptoPrice), line: 2 };\n            node.log(\"Displaying PRICE mode: \" + cryptoSymbol + \" - \" + cryptoPrice);\n            break;\n            \n        case 'change':\n            // Zeige Symbol und 24h-Änderung\n            line1 = { payload: formatForDisplay(cryptoSymbol + \" 24h\"), line: 1 };\n            line2 = { payload: formatForDisplay(cryptoChange), line: 2 };\n            node.log(\"Displaying CHANGE mode: \" + cryptoSymbol + \" - \" + cryptoChange);\n            break;\n            \n        case 'full':\n            // Zeige Symbol + Preis in Zeile 1, Änderung in Zeile 2\n            const fullLine1 = cryptoSymbol + \" \" + cryptoPrice;\n            line1 = { payload: formatForDisplay(fullLine1), line: 1 };\n            line2 = { payload: formatForDisplay(cryptoChange), line: 2 };\n            node.log(\"Displaying FULL mode: \" + fullLine1 + \" | \" + cryptoChange);\n            break;\n            \n        default:\n            // Fallback: Zeige nur Symbol und Preis\n            node.warn(\"Unknown crypto mode: \" + cryptoMode + \", defaulting to price display\");\n            line1 = { payload: formatForDisplay(cryptoSymbol + \" Kurs\"), line: 1 };\n            line2 = { payload: formatForDisplay(cryptoPrice), line: 2 };\n            break;\n    }\n    \n    // Zusätzliche Debug-Informationen\n    node.log(\"Final crypto display - Line 1: '\" + line1.payload + \"', Line 2: '\" + line2.payload + \"'\");\n}\n// Default fallback to time display\nelse {\n    node.warn(\"Unknown mode: \" + switchesMode + \", defaulting to TIME\");\n    line1 = { payload: \"Datum\", line: 1 };\n    line2 = { payload: cleanDateStr + \" \" + cleanTimeStr, line: 2 };\n}\n\n// Return both messages as array\nreturn [line1, line2];",
        "outputs": 2,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 2010,
        "y": 780,
        "wires": [
            [
                "151a953adf1df738"
            ],
            [
                "5a891e0d105c5864"
            ]
        ]
    },
    {
        "id": "cd04a40c673c7eee",
        "type": "template",
        "z": "73619a0e20b766b0",
        "name": "Build Write Command",
        "field": "payload",
        "fieldType": "msg",
        "format": "handlebars",
        "syntax": "mustache",
        "template": " --line \"{{line}}\" --message \"{{payload}}\"",
        "output": "str",
        "x": 2510,
        "y": 780,
        "wires": [
            [
                "37d4dde3f2ade25d",
                "02785858b756d613"
            ]
        ]
    },
    {
        "id": "5a891e0d105c5864",
        "type": "delay",
        "z": "73619a0e20b766b0",
        "name": "",
        "pauseType": "delay",
        "timeout": "200",
        "timeoutUnits": "milliseconds",
        "rate": "1",
        "nbRateUnits": "1",
        "rateUnits": "second",
        "randomFirst": "1",
        "randomLast": "5",
        "randomUnits": "seconds",
        "drop": false,
        "allowrate": false,
        "outputs": 1,
        "x": 2410,
        "y": 840,
        "wires": [
            [
                "cd04a40c673c7eee"
            ]
        ]
    },
    {
        "id": "37d4dde3f2ade25d",
        "type": "exec",
        "z": "73619a0e20b766b0",
        "command": "python /home/star2050/digilab/lcd/write.py",
        "addpay": "payload",
        "append": "",
        "useSpawn": "false",
        "timer": "",
        "winHide": false,
        "oldrc": false,
        "name": "Run Write Script",
        "x": 2790,
        "y": 780,
        "wires": [
            [
                "0b7b303e8658b7e5"
            ],
            [
                "7316b9a11ecd1b87"
            ],
            [
                "d508ef3e520866ee"
            ]
        ]
    },
    {
        "id": "02785858b756d613",
        "type": "debug",
        "z": "73619a0e20b766b0",
        "name": "Debug Write Command",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "x": 2820,
        "y": 720,
        "wires": []
    },
    {
        "id": "0b7b303e8658b7e5",
        "type": "debug",
        "z": "73619a0e20b766b0",
        "name": "Write stdout",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "x": 3020,
        "y": 760,
        "wires": []
    },
    {
        "id": "7316b9a11ecd1b87",
        "type": "debug",
        "z": "73619a0e20b766b0",
        "name": "Write stderr",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "x": 3020,
        "y": 800,
        "wires": []
    },
    {
        "id": "d508ef3e520866ee",
        "type": "debug",
        "z": "73619a0e20b766b0",
        "name": "Write RC",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "x": 3010,
        "y": 840,
        "wires": []
    },
    {
        "id": "310a38239b5a85ec",
        "type": "comment",
        "z": "73619a0e20b766b0",
        "name": "SWITCH INPUT SECTION",
        "info": "",
        "x": 440,
        "y": 1180,
        "wires": []
    },
    {
        "id": "297a65f921de75d9",
        "type": "rpi-gpio in",
        "z": "73619a0e20b766b0",
        "name": "Button2",
        "pin": "16",
        "intype": "down",
        "debounce": "100",
        "read": false,
        "bcm": true,
        "x": 50,
        "y": 1860,
        "wires": [
            [
                "172f611c7655f1aa",
                "4099fe7620e04b1d",
                "78defdd32aa8d72f",
                "crypto_manual_button"
            ]
        ]
    },
    {
        "id": "172f611c7655f1aa",
        "type": "function",
        "z": "73619a0e20b766b0",
        "name": "Cycle Through Weather Modes",
        "func": "// Only process when button is pressed (rising edge)\nif (msg.payload !== 1) return null;\n\n// Only cycle weather modes if we're in weather display mode\nconst switchesMode = flow.get('switches_mode') || 'time';\nif (switchesMode !== 'weather') {\n    // We're not in weather mode, so button does nothing\n    return null;\n}\n\n// Get current mode\nconst currentMode = flow.get('weather_mode') || 'temperature';\n\n// Define the cycle order - limited to just 4 essential modes\nconst modes = ['temperature', 'humidity', 'wind', 'description'];\n\n// Track button press count to prevent excessive cycling\nlet pressCount = flow.get('button_press_count') || 0;\npressCount++;\n\n// Store press count for debouncing purposes\nflow.set('button_press_count', pressCount);\nflow.set('last_button_press', Date.now());\n\n// Find current index\nlet currentIndex = modes.indexOf(currentMode);\n\n// If current mode not found in array, default to first mode\nif (currentIndex === -1) currentIndex = 0;\n\n// Move to next mode (or back to first if at end)\n// This ensures limited cycling through only 4 modes\nlet nextIndex = (currentIndex + 1) % modes.length;\n\n// Set the next mode\nconst nextMode = modes[nextIndex];\nflow.set('weather_mode', nextMode);\nmsg.payload = nextMode;\n\n// Also log mode change\nnode.log(\"Weather display mode changed to: \" + nextMode + \" (press #\" + pressCount + \")\");\n\n// Return the message with the new mode\nreturn msg;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 890,
        "y": 1080,
        "wires": [
            [
                "e0337f99aca4f801",
                "1996b9100a3bb7f4"
            ]
        ]
    },
    {
        "id": "4099fe7620e04b1d",
        "type": "debug",
        "z": "73619a0e20b766b0",
        "name": "Button Press",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 630,
        "y": 1120,
        "wires": []
    },
    {
        "id": "e0337f99aca4f801",
        "type": "debug",
        "z": "73619a0e20b766b0",
        "name": "Mode Changed",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 1160,
        "y": 1080,
        "wires": []
    },
    {
        "id": "789c0aec48a6fb3d",
        "type": "rpi-gpio in",
        "z": "73619a0e20b766b0",
        "name": "switch2",
        "pin": "20",
        "intype": "up",
        "debounce": "50",
        "read": true,
        "bcm": true,
        "x": 410,
        "y": 1220,
        "wires": [
            [
                "b63af0586ec5ebf7"
            ]
        ]
    },
    {
        "id": "3c5df00822c9a005",
        "type": "rpi-gpio in",
        "z": "73619a0e20b766b0",
        "name": "switch1",
        "pin": "21",
        "intype": "up",
        "debounce": "50",
        "read": true,
        "bcm": true,
        "x": 410,
        "y": 1280,
        "wires": [
            [
                "b63af0586ec5ebf7"
            ]
        ]
    },
    {
        "id": "b63af0586ec5ebf7",
        "type": "function",
        "z": "73619a0e20b766b0",
        "name": "Process Switch Changes",
        "func": "// Process input from GPIO pins\n// Check if the message has pin information in the topic\nconst isPinTopic = msg.topic && (msg.topic.includes(\"20\") || msg.topic.includes(\"21\"));\n\n// Store switch states based on pin number or explicit topic\nif (msg.topic === 'schalter1' || (isPinTopic && msg.topic.includes(\"21\"))) {\n    // For pull-up resistors: 0 = pressed/ON, 1 = not pressed/OFF\n    // If using pull-up, logical state is inverse of electrical state\n    flow.set('switch1', msg.payload === 0 ? 1 : 0);\n    node.log(\"Switch 1 set to: \" + flow.get('switch1') + \" (GPIO: \" + msg.payload + \")\");\n} else if (msg.topic === 'schalter2' || (isPinTopic && msg.topic.includes(\"20\"))) {\n    flow.set('switch2', msg.payload === 0 ? 1 : 0);\n    node.log(\"Switch 2 set to: \" + flow.get('switch2') + \" (GPIO: \" + msg.payload + \")\");\n} else {\n    node.log(\"Unknown switch input: \" + JSON.stringify({topic: msg.topic, payload: msg.payload}));\n}\n\n// Get current switch states\nconst switch1 = flow.get('switch1') || 0;\nconst switch2 = flow.get('switch2') || 0;\n\n// VERBESSERTE SWITCH-LOGIK: Prüfe zuerst die eindeutigen Zustände\nlet mode;\n\n// EINDEUTIGE ZUSTÄNDE ZUERST\nif (switch1 === 0 && switch2 === 0) {\n    mode = 'time';       // Both OFF - Uhrzeit-Modus\n    node.log(\"Switch Mode: BOTH OFF → TIME\");\n} \nelse if (switch1 === 1 && switch2 === 1) {\n    mode = 'crypto';     // Both ON - Quiz-Modus\n    node.log(\"Switch Mode: BOTH ON → QUIZ\");\n}\n// DANN DIE EINZELNEN SWITCHES\nelse if (switch1 === 1 && switch2 === 0) {\n    mode = 'weather';    // Switch 1 ON - Wetter-Modus\n    node.log(\"Switch Mode: SWITCH1 ON → WEATHER\");\n}\nelse if (switch1 === 0 && switch2 === 1) {\n    mode = 'Stock';      // Switch 2 ON - Aktien-Modus\n    node.log(\"Switch Mode: SWITCH2 ON → STOCK\");\n}\n// FALLBACK FÜR UNERWARTETE WERTE\nelse {\n    mode = 'time';  // Default fallback\n    node.warn(\"Unexpected switch values: S1=\" + switch1 + \", S2=\" + switch2 + \" → Defaulting to TIME\");\n}\n\n// Update mode and return message\nflow.set('switches_mode', mode);\nnode.log(\"Final Mode Set: \" + mode);\n\nreturn { payload: mode, topic: 'mode_change' };",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "// Initialize switch states\nflow.set('switch1', 0);\nflow.set('switch2', 0);\nflow.set('switches_mode', 'time');\nnode.log(\"Switch states initialized\");",
        "finalize": "",
        "libs": [],
        "x": 680,
        "y": 1250,
        "wires": [
            [
                "12688aa26a04e5ca",
                "1996b9100a3bb7f4"
            ]
        ]
    },
    {
        "id": "12688aa26a04e5ca",
        "type": "debug",
        "z": "73619a0e20b766b0",
        "name": "Switch Mode Debug",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 940,
        "y": 1250,
        "wires": []
    },
    {
        "id": "fast_clock_update",
        "type": "inject",
        "z": "73619a0e20b766b0",
        "name": "Update Clock (every second)",
        "props": [
            {
                "p": "payload"
            }
        ],
        "repeat": "1",
        "crontab": "",
        "once": true,
        "onceDelay": "2",
        "topic": "clock_update",
        "payload": "update_clock",
        "payloadType": "str",
        "x": 460,
        "y": 820,
        "wires": [
            [
                "clock_mode_check"
            ]
        ]
    },
    {
        "id": "clock_mode_check",
        "type": "function",
        "z": "73619a0e20b766b0",
        "name": "Only update if in clock mode",
        "func": "// Only proceed if we're in time mode\nconst currentMode = flow.get('switches_mode') || 'time';\nif (currentMode === 'time') {\n    return msg;\n}\nreturn null;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 950,
        "y": 820,
        "wires": [
            [
                "1996b9100a3bb7f4"
            ]
        ]
    },
    {
        "id": "f15478bfc1c3599a",
        "type": "function",
        "z": "73619a0e20b766b0",
        "name": "Aktien rotieren",
        "func": "// Liste der zu überwachenden Aktien\nconst stocks = ['AAPL', 'MSFT', 'GOOGL', 'AMZN', 'TSLA'];\n\n// Kontext für die aktuelle Position in der Liste abrufen\nconst currentIndex = context.get('stockIndex') || 0;\n\n// Zum nächsten Aktien-Symbol wechseln\nconst nextIndex = (currentIndex + 1) % stocks.length;\ncontext.set('stockIndex', nextIndex);\n\n// Nächstes Aktien-Symbol wählen\nconst nextStock = stocks[nextIndex];\n\n// Flow-Variable setzen\nflow.set('currentStock', nextStock);\n\n// Neue Nachricht mit aktuellem Aktien-Symbol erstellen\nmsg.symbol = nextStock;\nreturn msg;",
        "outputs": 1,
        "x": 640,
        "y": 1680,
        "wires": [
            [
                "a269df6103c55b01"
            ]
        ]
    },
    {
        "id": "a269df6103c55b01",
        "type": "http request",
        "z": "73619a0e20b766b0",
        "name": "Dynamischer Aktienabruf",
        "method": "GET",
        "ret": "obj",
        "paytoqs": "ignore",
        "url": "https://finnhub.io/api/v1/quote?symbol={{symbol}}&token=API-TOKEN",
        "tls": "",
        "persist": false,
        "proxy": "",
        "insecureHTTPParser": false,
        "authType": "",
        "senderr": false,
        "headers": [],
        "x": 860,
        "y": 1680,
        "wires": [
            [
                "ae68e326a10a4a39",
                "75d38e056053f7af"
            ]
        ]
    },
    {
        "id": "ae68e326a10a4a39",
        "type": "function",
        "z": "73619a0e20b766b0",
        "name": "Aktualisiere Aktie im Flow",
        "func": "// Überprüfe, ob überhaupt Daten vorhanden sind\nif (!msg.payload) {\n   node.error(\"Keine Daten empfangen - msg.payload ist null/undefined\");\n   return null;\n}\n\n// Debug-Info\nnode.log(\"Empfangene Daten: \" + JSON.stringify(msg.payload));\n\n// Prüfe auf Fehlermeldung in der API-Antwort\nif (msg.payload.error) {\n   node.error(\"API-Fehler: \" + msg.payload.error);\n   return null;\n}\n\n// Prüfe auf erforderliche Felder - VERBESSERTE FEHLERBEHANDLUNG\nif (typeof msg.payload.c === 'undefined' || msg.payload.c === null) {\n   // Setze Dummy-Daten für Tests\n   flow.set('stock_price', 'N/A');\n   flow.set('stock_change', 'N/A');\n   flow.set('stock_symbol', msg.symbol || 'AAPL');\n   \n   // Aktuelle Zeit\n   const now = new Date();\n   const hours = now.getHours();\n   const minutes = now.getMinutes();\n   const timeStr = hours + ':' + (minutes < 10 ? '0' : '') + minutes;\n   flow.set('current_time', timeStr);\n   \n   // Setze Stock Mode\n   flow.set('stock_mode', 'price');\n   flow.set('switches_mode', 'Stock');\n   \n   node.warn(\"Fehlende Aktiendaten - Dummy-Werte gesetzt\");\n   \n   // WICHTIG: Nachricht weitergeben, damit Display aktualisiert wird\n   msg.payload = 'stock_data_updated';\n   return msg;\n}\n\n// ===== ERFOLGREICHE DATENVERARBEITUNG =====\nconst stockData = msg.payload;\nconst symbol = msg.symbol || 'AAPL';\n\nnode.log(\"Verarbeitung startet für Symbol: \" + symbol);\n\n// Aktuelle Zeit\nconst now = new Date();\nconst hours = now.getHours();\nconst minutes = now.getMinutes();\nconst timeStr = hours + ':' + (minutes < 10 ? '0' : '') + minutes;\n\n// Aktienpreis und Änderungen (behalte die ursprünglichen Zahlen)\nconst currentPrice = stockData.c.toFixed(2) + '$';\nconst change = stockData.d || 0;  // Fallback auf 0 wenn nicht vorhanden\nconst percentChangeValue = stockData.dp || 0;  // Fallback auf 0 wenn nicht vorhanden\n\nnode.log(\"Rohdaten - Preis: \" + stockData.c + \", Änderung: \" + change + \", Prozent: \" + percentChangeValue);\n\n// Pfeil-Symbol basierend auf Kursänderung (ASCII für LCD-Display)\nconst arrow = percentChangeValue >= 0 ? '^' : 'v';\nconst changeFormat = arrow + ' ' + Math.abs(change).toFixed(2) + '$ (' + Math.abs(percentChangeValue).toFixed(2) + '%)';\n\nnode.log(\"Formatierte Daten - Preis: \" + currentPrice + \", Änderung: \" + changeFormat);\n\n// ===== SPEICHERE ALLE DATEN IM FLOW-KONTEXT =====\nflow.set('stock_price', currentPrice);\nflow.set('stock_change', changeFormat);\nflow.set('stock_symbol', symbol);\nflow.set('current_time', timeStr);\n\n// Rotiere Stock Mode automatisch bei jedem Update (price -> change -> full)\nconst modes = ['price', 'change', 'full'];\nconst currentMode = flow.get('stock_mode') || 'price';\nconst currentIndex = modes.indexOf(currentMode);\nconst nextIndex = (currentIndex + 1) % modes.length;\nconst nextMode = modes[nextIndex];\nflow.set('stock_mode', nextMode);\n\nnode.log(\"Stock Mode gewechselt von '\" + currentMode + \"' zu '\" + nextMode + \"'\");\n\n// Setze switches_mode auf Stock (damit Display auf Stock-Modus wechselt)\nflow.set('switches_mode', 'Stock');\n\n// Füge Zeitstempel der letzten Aktualisierung hinzu\nflow.set('last_updated', Date.now());\n\n// Log für Debug\nnode.log(\"✅ Aktie \" + symbol + \" erfolgreich aktualisiert: \" + currentPrice + \" \" + changeFormat);\n\n// Sende Nachricht für Display-Update\nmsg.payload = 'stock_updated';\nmsg.symbol = symbol;\nmsg.price = currentPrice;\nmsg.change = changeFormat;\nmsg.mode = nextMode;\n\nreturn msg;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1110,
        "y": 1680,
        "wires": [
            [
                "596da07b881a8e24",
                "1996b9100a3bb7f4"
            ]
        ]
    },
    {
        "id": "56b01de72cde712b",
        "type": "rpi-gpio in",
        "z": "73619a0e20b766b0",
        "name": "Button1",
        "pin": "19",
        "intype": "down",
        "debounce": "100",
        "read": false,
        "bcm": true,
        "x": 50,
        "y": 1920,
        "wires": [
            []
        ]
    },
    {
        "id": "75d38e056053f7af",
        "type": "debug",
        "z": "73619a0e20b766b0",
        "name": "debug 1",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "false",
        "statusVal": "",
        "statusType": "auto",
        "x": 1060,
        "y": 1640,
        "wires": []
    },
    {
        "id": "596da07b881a8e24",
        "type": "debug",
        "z": "73619a0e20b766b0",
        "name": "debug 3",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "false",
        "statusVal": "",
        "statusType": "auto",
        "x": 1360,
        "y": 1680,
        "wires": []
    },
    {
        "id": "151a953adf1df738",
        "type": "delay",
        "z": "73619a0e20b766b0",
        "name": "",
        "pauseType": "delay",
        "timeout": "30",
        "timeoutUnits": "milliseconds",
        "rate": "1",
        "nbRateUnits": "1",
        "rateUnits": "second",
        "randomFirst": "1",
        "randomLast": "5",
        "randomUnits": "seconds",
        "drop": false,
        "allowrate": false,
        "outputs": 1,
        "x": 2270,
        "y": 740,
        "wires": [
            [
                "cd04a40c673c7eee"
            ]
        ]
    },
    {
        "id": "0f60d230ee7f1d8d",
        "type": "inject",
        "z": "73619a0e20b766b0",
        "name": "Aktienmarkt Update (alle 5 min)",
        "props": [
            {
                "p": "payload"
            }
        ],
        "repeat": "600",
        "crontab": "",
        "once": true,
        "onceDelay": "5",
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 420,
        "y": 1380,
        "wires": [
            [
                "3abb43a9e49a8bdd"
            ]
        ]
    },
    {
        "id": "36b0baf81d79c4cc",
        "type": "function",
        "z": "73619a0e20b766b0",
        "name": "Formatiere und speichere Aktiendaten",
        "func": "// Überprüfe, ob überhaupt Daten vorhanden sind\nif (!msg.payload) {\n   node.error(\"Keine Daten empfangen\");\n   return null;\n}\n\n// Debug-Info\nnode.log(\"Empfangene Daten: \" + JSON.stringify(msg.payload));\n\n// Prüfe auf Fehlermeldung in der API-Antwort\nif (msg.payload.error) {\n   node.error(\"API-Fehler: \" + msg.payload.error);\n   return null;\n}\n\n// Prüfe auf erforderliche Felder\nif (typeof msg.payload.c === 'undefined') {\n   // Setze Dummy-Daten für Tests\n   flow.set('stock_price', 'N/A');\n   flow.set('stock_change', 'N/A');\n   flow.set('stock_symbol', msg.symbol || 'AAPL');\n   flow.set('current_time', new Date().toLocaleTimeString('de-DE'));\n   flow.set('switches_mode', 'Stock');\n   node.warn(\"Fehlende Aktiendaten - Dummy-Werte gesetzt\");\n   return msg;\n}\n\n// Extrahiere und formatiere Daten\nconst stockData = msg.payload;\nconst symbol = msg.symbol || 'AAPL';\n\n// Aktuelle Zeit\nconst now = new Date();\nconst hours = now.getHours();\nconst minutes = now.getMinutes();\nconst timeStr = hours + ':' + (minutes < 10 ? '0' : '') + minutes;\n\n// Aktienpreis und Änderungen\nconst currentPrice = stockData.c.toFixed(2) + '$';\nconst change = stockData.d.toFixed(2);\nconst percentChange = stockData.dp.toFixed(2);\n\n// Pfeil-Symbol basierend auf Kursänderung (ASCII-Version)\nconst arrow = percentChange >= 0 ? '^' : 'v';\nconst changeFormat = arrow + ' ' + Math.abs(change) + '$ (' + Math.abs(percentChange) + '%)';\n\n// Speichere alle Daten im Flow-Kontext\nflow.set('stock_price', currentPrice);\nflow.set('stock_change', changeFormat);\nflow.set('stock_symbol', symbol);\nflow.set('current_time', timeStr);\n\n// Rotiere Stock Mode (price -> change -> full)\nconst modes = ['price', 'change', 'full'];\nconst currentMode = flow.get('stock_mode') || 'price';\nconst currentIndex = modes.indexOf(currentMode);\nconst nextIndex = (currentIndex + 1) % modes.length;\nflow.set('stock_mode', modes[nextIndex]);\n\n// Setze switches_mode auf Stock\nflow.set('switches_mode', 'Stock');\n\nreturn msg;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1210,
        "y": 1380,
        "wires": [
            [
                "85e67035ab842076"
            ]
        ]
    },
    {
        "id": "85e67035ab842076",
        "type": "function",
        "z": "73619a0e20b766b0",
        "name": "Stock Data Processor",
        "func": "// VOLLSTÄNDIGE DEBUG-VERSION\nnode.log(\"=== STOCK DATA PROCESSOR DEBUG ===\");\n\n// 1. Überprüfe gesamte Nachricht\nnode.log(\"Komplette Nachricht: \" + JSON.stringify(msg, null, 2));\n\n// 2. Überprüfe Payload-Typ und -Inhalt\nnode.log(\"Payload-Typ: \" + typeof msg.payload);\nnode.log(\"Payload-Inhalt: \" + JSON.stringify(msg.payload, null, 2));\n\n// 3. Überprüfe, ob überhaupt Daten vorhanden sind\nif (!msg.payload) {\n   node.error(\"Keine Daten empfangen - msg.payload ist null/undefined\");\n   return null;\n}\n\n// 4. Prüfe auf Fehlermeldung in der API-Antwort\nif (msg.payload.error) {\n   node.error(\"API-Fehler: \" + msg.payload.error);\n   return null;\n}\n\n// 5. Detaillierte Analyse der verfügbaren Felder\nconst availableFields = Object.keys(msg.payload);\nnode.log(\"Verfügbare Felder in payload: \" + JSON.stringify(availableFields));\n\n// 6. Prüfe spezifisch auf 'c' Feld\nnode.log(\"msg.payload.c existiert: \" + (msg.payload.hasOwnProperty('c')));\nnode.log(\"msg.payload.c Wert: \" + msg.payload.c);\nnode.log(\"msg.payload.c Typ: \" + typeof msg.payload.c);\n\n// Rest der Funktion...\nif (typeof msg.payload.c === 'undefined' || msg.payload.c === null) {\n   node.warn(\"Feld 'c' (current price) fehlt oder ist null\");\n   \n   // Setze Dummy-Daten\n   flow.set('stock_price', 'N/A');\n   flow.set('stock_change', 'N/A');\n   flow.set('stock_symbol', msg.symbol || 'AAPL');\n   \n   const now = new Date();\n   const timeStr = now.getHours() + ':' + (now.getMinutes() < 10 ? '0' : '') + now.getMinutes();\n   flow.set('current_time', timeStr);\n   flow.set('stock_mode', 'price');\n   flow.set('switches_mode', 'Stock');\n   \n   node.warn(\"Dummy-Werte gesetzt - Display wird trotzdem aktualisiert\");\n   msg.payload = 'stock_data_updated';\n   return msg;\n}\n\n// Normale Verarbeitung wenn Daten da sind\nconst stockData = msg.payload;\nconst symbol = msg.symbol || 'AAPL';\nnode.log(\"Verarbeitung startet für Symbol: \" + symbol);\n\nreturn msg;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1560,
        "y": 1540,
        "wires": [
            [
                "42dccb0453774a1f"
            ]
        ]
    },
    {
        "id": "fetch_stock_data",
        "type": "http request",
        "z": "73619a0e20b766b0",
        "name": "Abruf Aktiendaten",
        "method": "GET",
        "ret": "obj",
        "paytoqs": "ignore",
        "url": "https://finnhub.io/api/v1/quote?symbol=AAPL&token=API-TOKEN",
        "tls": "",
        "persist": false,
        "proxy": "",
        "insecureHTTPParser": false,
        "authType": "",
        "senderr": false,
        "headers": [],
        "x": 950,
        "y": 1380,
        "wires": [
            [
                "36b0baf81d79c4cc"
            ]
        ]
    },
    {
        "id": "42dccb0453774a1f",
        "type": "debug",
        "z": "73619a0e20b766b0",
        "name": "debug 2",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "false",
        "statusVal": "",
        "statusType": "auto",
        "x": 1750,
        "y": 1620,
        "wires": []
    },
    {
        "id": "ab0cf9e476c8846c",
        "type": "delay",
        "z": "73619a0e20b766b0",
        "name": "",
        "pauseType": "delay",
        "timeout": "1",
        "timeoutUnits": "seconds",
        "rate": "1",
        "nbRateUnits": "1",
        "rateUnits": "second",
        "randomFirst": "1",
        "randomLast": "5",
        "randomUnits": "seconds",
        "drop": false,
        "allowrate": false,
        "outputs": 1,
        "x": 2140,
        "y": 1020,
        "wires": [
            [
                "d72a326f373d8fc1"
            ]
        ]
    },
    {
        "id": "78defdd32aa8d72f",
        "type": "function",
        "z": "73619a0e20b766b0",
        "name": "Only update if in clock mode",
        "func": "// Only proceed if we're in time mode\nconst currentMode = flow.get('switches_mode') || 'Stock';\nif (currentMode === 'Stock') {\n    return msg;\n}\nreturn null;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 320,
        "y": 1680,
        "wires": [
            [
                "f15478bfc1c3599a"
            ]
        ]
    },
    {
        "id": "3abb43a9e49a8bdd",
        "type": "function",
        "z": "73619a0e20b766b0",
        "name": "Only update if in clock mode",
        "func": "// Only proceed if we're in time mode\nconst currentMode = flow.get('switches_mode') || 'Stock';\nif (currentMode === 'Stock') {\n    return msg;\n}\nreturn null;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 700,
        "y": 1380,
        "wires": [
            [
                "fetch_stock_data"
            ]
        ]
    },
    {
        "id": "crypto_timer_inject",
        "type": "inject",
        "z": "73619a0e20b766b0",
        "name": "Crypto Update (every 5min)",
        "props": [
            {
                "p": "payload"
            }
        ],
        "repeat": "300",
        "crontab": "",
        "once": true,
        "onceDelay": "7",
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 340,
        "y": 2200,
        "wires": [
            [
                "crypto_http_request"
            ]
        ]
    },
    {
        "id": "crypto_http_request",
        "type": "http request",
        "z": "73619a0e20b766b0",
        "name": "Get Crypto Data",
        "method": "GET",
        "ret": "obj",
        "paytoqs": "ignore",
        "url": "https://api.coingecko.com/api/v3/simple/price?ids=bitcoin,ethereum,cardano,polkadot,chainlink&vs_currencies=usd&include_24hr_change=true",
        "tls": "",
        "persist": false,
        "proxy": "",
        "insecureHTTPParser": false,
        "authType": "",
        "senderr": false,
        "headers": [],
        "x": 610,
        "y": 2200,
        "wires": [
            [
                "crypto_process_data",
                "crypto_debug_response"
            ]
        ]
    },
    {
        "id": "crypto_debug_response",
        "type": "debug",
        "z": "73619a0e20b766b0",
        "name": "Crypto API Response",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 830,
        "y": 2160,
        "wires": []
    },
    {
        "id": "crypto_process_data",
        "type": "function",
        "z": "73619a0e20b766b0",
        "name": "Process Crypto Data",
        "func": "// Check if we have valid data\nif (!msg.payload) {\n    node.error(\"No crypto data received\");\n    return null;\n}\n\n// Debug info\nnode.log(\"Received crypto data: \" + JSON.stringify(msg.payload));\n\n// Check for API error\nif (msg.payload.error) {\n    node.error(\"Crypto API error: \" + msg.payload.error);\n    return null;\n}\n\n// Define crypto symbols and their display names\nconst cryptos = [\n    { id: 'bitcoin', symbol: 'BTC', name: 'Bitcoin' },\n    { id: 'ethereum', symbol: 'ETH', name: 'Ethereum' },\n    { id: 'cardano', symbol: 'ADA', name: 'Cardano' },\n    { id: 'polkadot', symbol: 'DOT', name: 'Polkadot' },\n    { id: 'chainlink', symbol: 'LINK', name: 'Chainlink' }\n];\n\n// Current time\nconst now = new Date();\nconst hours = now.getHours();\nconst minutes = now.getMinutes();\nconst timeStr = hours + ':' + (minutes < 10 ? '0' : '') + minutes;\n\n// Get current crypto index for rotation\nlet currentIndex = flow.get('crypto_index') || 0;\nconst currentCrypto = cryptos[currentIndex];\n\n// Check if the crypto data exists\nif (!msg.payload[currentCrypto.id]) {\n    node.warn(\"No data for \" + currentCrypto.name + \", using fallback\");\n    // Set fallback values\n    flow.set('crypto_price', 'N/A');\n    flow.set('crypto_change', 'N/A');\n    flow.set('crypto_symbol', currentCrypto.symbol);\n    flow.set('crypto_name', currentCrypto.name);\n    flow.set('current_time', timeStr);\n} else {\n    // Extract crypto data\n    const cryptoData = msg.payload[currentCrypto.id];\n    const price = cryptoData.usd;\n    const change24h = cryptoData.usd_24h_change || 0;\n\n    // Format price (different formatting for different price ranges)\n    let formattedPrice;\n    if (price >= 1000) {\n        formattedPrice = '$' + price.toFixed(0); // No decimals for high prices\n    } else if (price >= 1) {\n        formattedPrice = '$' + price.toFixed(2); // 2 decimals for mid prices\n    } else {\n        formattedPrice = '$' + price.toFixed(4); // 4 decimals for low prices\n    }\n\n    // Format 24h change with arrow\n    const arrow = change24h >= 0 ? '^' : 'v';\n    const changeFormatted = arrow + ' ' + Math.abs(change24h).toFixed(2) + '%';\n\n    // Store data in flow context\n    flow.set('crypto_price', formattedPrice);\n    flow.set('crypto_change', changeFormatted);\n    flow.set('crypto_symbol', currentCrypto.symbol);\n    flow.set('crypto_name', currentCrypto.name);\n    flow.set('current_time', timeStr);\n\n    node.log(\"Crypto data processed: \" + currentCrypto.symbol + \" = \" + formattedPrice + \" (\" + changeFormatted + \")\");\n}\n\n// Rotate to next crypto for next update\nconst nextIndex = (currentIndex + 1) % cryptos.length;\nflow.set('crypto_index', nextIndex);\n\n// Set default crypto mode if not set\nif (!flow.get('crypto_mode')) {\n    flow.set('crypto_mode', 'price');\n}\n\n// Add last_updated timestamp\nflow.set('crypto_last_updated', Date.now());\n\n// Send current switches mode to the display handler\nconst switchesMode = flow.get('switches_mode') || 'time';\nmsg.payload = switchesMode;\n\nreturn msg;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 870,
        "y": 2200,
        "wires": [
            [
                "crypto_debug_processed",
                "1996b9100a3bb7f4"
            ]
        ]
    },
    {
        "id": "crypto_debug_processed",
        "type": "debug",
        "z": "73619a0e20b766b0",
        "name": "Crypto Data Processed",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 1130,
        "y": 2160,
        "wires": []
    },
    {
        "id": "crypto_error_recovery",
        "type": "inject",
        "z": "73619a0e20b766b0",
        "name": "Crypto Error Recovery (every hour)",
        "props": [
            {
                "p": "payload"
            }
        ],
        "repeat": "3600",
        "crontab": "",
        "once": false,
        "onceDelay": 0,
        "topic": "",
        "payload": "check",
        "payloadType": "str",
        "x": 330,
        "y": 2260,
        "wires": [
            [
                "crypto_check_updates"
            ]
        ]
    },
    {
        "id": "crypto_check_updates",
        "type": "function",
        "z": "73619a0e20b766b0",
        "name": "Check Crypto Update Time",
        "func": "// Get last update timestamp\nconst lastUpdated = flow.get('crypto_last_updated') || 0;\nconst now = Date.now();\n\n// If no update in the last 20 minutes (1200000ms), force refresh\nif (now - lastUpdated > 1200000) {\n    node.warn(\"No crypto updates for 20+ minutes. Forcing refresh.\");\n    // Set payload to trigger a new crypto fetch\n    msg.payload = Date.now();\n    return msg;\n}\n\n// Otherwise no need to do anything\nreturn null;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 650,
        "y": 2260,
        "wires": [
            [
                "crypto_http_request"
            ]
        ]
    },
    {
        "id": "crypto_comment",
        "type": "comment",
        "z": "73619a0e20b766b0",
        "name": "CRYPTO DATA SECTION",
        "info": "",
        "x": 360,
        "y": 2120,
        "wires": []
    },
    {
        "id": "crypto_manual_button",
        "type": "function",
        "z": "73619a0e20b766b0",
        "name": "Manual Crypto Switch (Button2)",
        "func": "// Only process when button is pressed (rising edge)\nif (msg.payload !== 1) return null;\n\n// Only cycle crypto if we're in krypto display mode\nconst switchesMode = flow.get('switches_mode') || 'time';\nif (switchesMode !== 'crypto') {\n    // We're not in krypto mode, so button does nothing\n    return null;\n}\n\n// Define crypto symbols and their display names\nconst cryptos = [\n    { id: 'bitcoin', symbol: 'BTC', name: 'Bitcoin' },\n    { id: 'ethereum', symbol: 'ETH', name: 'Ethereum' },\n    { id: 'cardano', symbol: 'ADA', name: 'Cardano' },\n    { id: 'polkadot', symbol: 'DOT', name: 'Polkadot' },\n    { id: 'chainlink', symbol: 'LINK', name: 'Chainlink' }\n];\n\n// Get current crypto index for manual rotation\nlet currentIndex = flow.get('crypto_index') || 0;\n\n// Move to next crypto manually\nconst nextIndex = (currentIndex + 1) % cryptos.length;\nflow.set('crypto_index', nextIndex);\n\nconst nextCrypto = cryptos[nextIndex];\nnode.log(\"Manual crypto switch to: \" + nextCrypto.symbol);\n\n// Trigger immediate API call for the new crypto\nmsg.payload = Date.now();\nmsg.symbol = nextCrypto.id;\nmsg.manual_switch = true;\n\nreturn msg;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 350,
        "y": 1860,
        "wires": [
            [
                "crypto_http_request"
            ]
        ]
    }
]